//Ефимов Сергей
#include<iostream>
#include <conio.h>

#define SIZE 9
using namespace std;

//функция, которая выводит массив в консоль
void print(int a[])
{
    for (int i = 0; i < SIZE; i++)
    {
        cout << a[i] << "  ";
    }
}

int Partition(int a[], int left, int right)
{
    int temp = left, support = a[left], element; //support - опорная точка, тут я беру самую левую часть массива
    //процесс выполнения подробно описан ниже
    for (element = left + 1; element <= right; element++)
    {
        if (support > a[element])
        {
            a[temp] = a[element];
            a[element] = a[temp + 1];
            a[temp + 1] = support;

            temp = temp + 1;
        }
    }
    return temp;
}

void QuickSort(int a[], int beg, int end)
{
    if (beg < end)
    {
        int supportPoint = Partition(a, beg, end);
        QuickSort(a, beg, supportPoint - 1);
        QuickSort(a, supportPoint + 1, end);
    }
}


int main()
{
    setlocale(LC_ALL, "Russian");
    int array[SIZE] = { 3, 5, 8, 1, 2, 9, 4, 7, 6 };
    //выбираю число в качестве эталона для сортировки, Такое число называется "опорный элемент"
    cout << "Массив до сортировки: " << endl;
    print(array); cout << endl;
    int support_element = array[SIZE - 1];
    //Сейчас, для удобства, это крайнее правое число.

    int left = 0, right = SIZE - 2;
    //теперь создаю маркеры, которые в дальнейшем будут использоваться 

    //левый маркер будет сдвигаться вправо, пока не достигнет
    //числа, которое больше или равно опорному элементу
    //он останавливает движение

    while (array[left] <= support_element)
    {
        left++;
    }
    //В данном случае 8 больше чем 6, маркер останавливается.

    //затем правый маркер начинает движение влево
    //когда правый маркер достигает числа меньшего, чем опорное число, 
    //он останавливается.

    while (array[right] > support_element)
    {
        right--;
    }
    //4 меньше чем 6 - маркер останавливается.

    //когда оба маркера остановились, числа, на которые они указывали, 
    //меняются местами
    int temp = array[left];
    array[left] = array[right];
    array[right] = temp;

    //далее, левый маркер ищет числа большие или равные опроному элементу,
    //а правый нмаркер находит числа меньшие, чем опорный элемент

    //меняя числа местами, мы собираем числа, которые меньше опорного
    //элемента на левой стороне последовательности, а с правой стороны числа, 
    //числа, которые больше или равные ему.

    //после обмена левый маркер продолжает двигаться направо.
    while (array[left] <= support_element)
    {
        left++;
    }
    //9 больше чем 6, маркер останавливается.

    //Теперь правый маркер снова движется влево. 
    while (array[right] > support_element && right != left)
    {
        right--;
    }
    
    //движение маркера также останавливается, если правый маркер 
    //достигнет позиции левого маркера

    /*когда оба маркера, левый и правый останавливаются и одновременно
    находятся в одной и тоже позиции, то число, на которое они указывают,
    меняется местами с опорным элементом.
    */
    temp = support_element;
    array[SIZE - 1] = array[right];//array[left]
    array[right] = temp; array[left] = temp;

    
    //Число, на которое указывают оба маркера, считает полностью отсортированным
    //это завершает первый цикл вычислений.

    /*В этом цикле вычислений мы смогли переместить числа меньшие, чем опорный элемент,
    * в сторону левее от него, а числа, которые больше опорного элемента - правее от него.
    * Следующий цикл будет выполнен рекурсивно на частях последовательности, созданным опорным элементом
    * сперва вычисления будут выполняться на части последовательности, слве от опорного элемента. 
    То есть, все цифры которые правее индека right и left сейчас не трогаем, они уже отсортированы.*/

    //Теперь снова нужно выбрать опроный элемент, левую маркер и правый маркер. 
    //Однако сейчас можно использовать некоторые функции, позволяющие облегчить работу.
    QuickSort(array, 0, right - 1);//принимает массив, стартовую точку откуда начинать, и конец массива.
    cout << "Массив после сортировки: " << endl;
    print(array);
}
